<!doctype html>
<html>

<head>
  <title>CSGO Inventory Valuator</title>
</head>

<body>
  <div>Steam Inventory <span id="loadingSteamInventory"></span></div>
  <div>Steam Prices <span id="loadingSteamPrices"></span></div>
  <div>OpSkins Prices <span id="loadingOpSkinsPrices"></span></div>
  <div>BitSkins Prices <span id="loadingBitSkinsPrices"></span></div>
  <p id="total"></p>
  <ul id="types">

  </ul>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Amount</th>
        <th id="thOpSkins">OpSkins</th>
      </tr>
    </thead>
    <tbody id="tableBody">
    </tbody>
  </table>
</body>

</html>

<script>

  let api = {
    prices: {
      opskins: 'https://api.opskins.com/IPricing/GetAllLowestListPrices/v1/?appid=730',
      bitskins: '',
      steam: ''
    },
    inventory: 'http://steamcommunity.com/inventory/76561198060787905/730/2?l=english&count=5000', // James' Inventory
    cors: 'https://crossorigin.me/'
  };

  let pricesOpSkins = null;
  let pricesSteam = null;
  let pricesBitSkins = null;

  let inventoryUnfiltered = [];
  let inventoryFiltered = [];

  let types = [];

  let sortByPrice = 'ascending';


  window.onload = function () {
    let loadingSteamInventory = document.getElementById('loadingSteamInventory');
    let loadingOpSkinsPrices = document.getElementById('loadingOpSkinsPrices');
    let loadingSteamPrices = document.getElementById('loadingSteamPrices');
    let loadingBitSkinsPrices = document.getElementById('loadingBitSkinsPrices');

    /*getSteamInventory();
    getPricesOpSkins();*/

    getSteamInventory()
      .then(getPricesOpSkins)
      .then(getPricesBitSkins)
      .then(getPricesSteam)
    
    
    
    // TODO: these need to be called after the other stuff
    /*
    getTypes(inventoryUnfiltered);
    sortTypesAmount('descending');
    printTypes();
    // fill table
    populateTable(inventoryUnfiltered);
    */
  };

  

  let getSteamInventory = function() {
    let promise = new Promise(function(resolve, reject){
      console.log('Getting steam inventory....');
      loadingSteamInventory.innerHTML = 'Loading...'

      callApi(api.cors + api.inventory,function(){
        loadingSteamInventory.innerHTML = 'DONE';
        resolve();
        
        // TODO: Parse inventory here while loading carries on
      });

    });
    return promise;
  };

  let getPricesOpSkins = function() {
    let promise = new Promise(function(resolve, reject){
      console.log('Getting OpSkins prices....');
      loadingOpSkinsPrices.innerHTML = 'Loading...';

      callApi(api.prices.opskins,function(){
        loadingOpSkinsPrices.innerHTML = 'DONE';
        resolve();
      });

    });
    return promise;
  };
  let getPricesBitSkins = function() {
    let promise = new Promise(function(resolve, reject){
      console.log('Getting Bitskins prices....');
      loadingBitSkinsPrices.innerHTML = 'Loading...';

      /*callApi(api.prices.opskins,function(){
        resolve();
      });*/
      resolve();

    });
    return promise;
  };

  let getPricesSteam = function() {
    let promise = new Promise(function(resolve, reject){
      console.log('Getting Steam prices....');
      loadingSteamPrices.innerHTML = 'Loading...';

      /*callApi(api.prices.opskins,function(){
        resolve();
      });*/
      resolve();

    });
    return promise;
  };



  function callApi(url,callback){
    fetch(url).then(function(response) {
      return response.json();
    }).then(function(response){
      callback();
    });
  }  
 

  /** Handle OpSkins prices */
  function handlePricesOpSkins(response){
    if (response.status == 1) {
      console.log('getPricesOpSkins successful...');
      pricesOpSkins = response.response;
      console.log(pricesOpSkins);
    }
    else {
      console.log('getPriceOpSkins failed...')
    }
  }

  

  /** Handle Steam inventory */
  function handleSteamInventory(response){
    console.log('getSteamInventoryTest successful...');
    inventoryUnfiltered = inventoryGroupItems(response);
    /*  Some items have different properties, eg 2 of the same skin but with different stickers, meaning they have
        the same name but have different classids. This sorts through the items that have the same name but different class ids */
    inventoryUnfiltered = removeDuplicateNameEntries(inventoryUnfiltered);
    /* now remove all the null rows so we have no issues when making the table */
    inventoryUnfiltered = removeNullsFromArray(inventoryUnfiltered);
    inventoryUnfiltered = sanitiseArray(inventoryUnfiltered);
    console.log(inventoryUnfiltered);
  }

  /** groups duplicate items together */
  function inventoryGroupItems(response) {

    // Count number of each item
    let tempInventory = [];
    response.assets.forEach(element => {
      let contains = { found: false, index: 0 };
      for (let i = 0; i < tempInventory.length; i++) {
        if (tempInventory[i].classid == element.classid) {
          contains.found = true;
          contains.index = i;
          break;
        }
      }
      if (contains.found) {
        tempInventory[contains.index].amount += 1;
      }
      else {
        tempInventory.push({
          classid: element.classid,
          amount: 1,
        });
      }
    });

    // add details to each item
    tempInventory.forEach(item => {
      for (let i = 0; i < response.descriptions.length; i++) {
        if (item.classid == response.descriptions[i].classid) {
          item.name = response.descriptions[i].market_hash_name;
          item.type = response.descriptions[i].type;
          item.tag_type = response.descriptions[i].tags[0].localized_tag_name;
          break;
        }
      }
    });

    return tempInventory
  }
  function populateTable(inventory) {
    let tableBody = document.getElementById('tableBody');
    tableBody.innerHTML = '';
    inventory.forEach(element => {
      tableBody.innerHTML += '<tr><td>' + element.name + '</td><td>' + element.type + '</td><td>' + element.amount + '</td><td>' + '$' + element.price + '</td></tr>';
    });
  }
  function removeDuplicateNameEntries(array) {
    for (let i = 0; i < array.length; i++) {
      for (let j = 0; j < array.length; j++) {
        if (array[i] != null && array[j] != null && array[i].name == array[j].name && i != j) {
          array[i].amount += array[j].amount;
          array[j] = null;
        }
      }
    }
    return array;
  }
  function removeNullsFromArray(array) {
    for (let i = 0; i < array.length; i++) {
      if (array[i] == null) {
        array.splice(i, 1)
        i--;
      }
    }
    return array;
  }
  /*
  * Remove items such as stock skins from array that mess up the program
  * TODO: should not remove them but mark as something else
  */
  function sanitiseArray(array) {
    for (let i = 0; i < array.length; i++) {
      if (array[i].type.includes('Stock')) {
        array.splice(i, 1)
        i--;
      }
    }
    return array;
  }
  // Get different types from items for sorting
  function getTypes(array) {
    array.forEach(item => {
      let contains = { found: false, index: 0 };
      for (let i = 0; i < types.length; i++) {
        if (types[i].type == item.type) {
          contains.found = true;
          contains.index = i;
          break;
        }
      }
      if (contains.found) {
        types[contains.index].amount += item.amount;
      }
      else {
        types.push({
          type: item.type,
          amount: item.amount,
        });
      }
    });
  }
  // print types onto screen, setting up click events for sorting
  function printTypes() {
    let typeArea = document.getElementById('types');

    for (let i = 0; i < types.length; i++) {
      let tempID = 'type' + i;
      typeArea.innerHTML += '<li id="' + tempID + '">' + types[i].type + ' - ' + types[i].amount + '</li>';
    }

    for (let i = 0; i < types.length; i++) {
      let tempID = 'type' + i;
      document.getElementById(tempID).addEventListener('click', function () {
        filterInventory(types[i].type);
        populateTable(inventoryFiltered);
      }, false);
    }
  }

  // sort types by amount 
  function sortTypesAmount(order) {
    let compare;
    if (order == 'ascending') {
      compare = function (a, b) {
        if (a.amount < b.amount)
          return -1;
        if (a.amount > b.amount)
          return 1;
        return 0;
      }
      types.sort(compare);
    }
    else if (order == 'descending') {
      compare = function (a, b) {
        if (a.amount < b.amount)
          return 1;
        if (a.amount > b.amount)
          return -1;
        return 0;
      }
      types.sort(compare);
    }
    else {
      alert('Yo, enter a correct value for sorting types friend');
    }
  }

  // sort by price
  function sortInventoryByPrice() {
    let compare;
    //already descending, change to ascending and sort ascending
    if (sortByPrice == 'descending') {
      sortByPrice = 'ascending';
      compare = function (a, b) {
        if (a.price < b.price)
          return -1;
        if (a.price > b.price)
          return 1;
        return 0;
      }
      inventoryUnfiltered.sort(compare);
    } else if (sortByPrice == 'ascending') { // already ascending, change to desecnding and sort descedning
      sortByPrice = 'descending';
      compare = function (a, b) {
        if (a.price < b.price)
          return 1;
        if (a.price > b.price)
          return -1;
        return 0;
      }
      inventoryUnfiltered.sort(compare);
    } else {
      alert('Yo, value wrong for sorting prices friend');
    }
  }

  // reset screen
  function reset() {
    inventoryUnfiltered = [];
    types = [];
    document.getElementById('total').innerHTML = '';
    document.getElementById('types').innerHTML = '';
    document.getElementById('tableBody').innerHTML = '';
  }
  function updatePricesOpSkins() {
    inventoryUnfiltered.forEach(item => {
      // REMOVE THIS ONCE STOCK WEAPONS ARE REMOVED FROM INVENTORY
      try {
        item.price = (pricesOpSkins[item.name].price / 100);
      }
      catch (e) {
        // shout out to cathal
      }
    });
  }
  // filter items by type
  function filterInventory(type) {
    inventoryFiltered = [];
    inventoryUnfiltered.forEach(item => {
      if (item.type == type) {
        inventoryFiltered.push(item);
      }
    });
  }
  function tempPopTable(inventory) {
    let tableBody = document.getElementById('tableBody');
    tableBody.innerHTML = '';
    inventory.forEach(element => {
      tableBody.innerHTML += '<tr><td>' + element.name + '</td><td>' + '$' + element.price + '</td><td>'  + element.amount + '</td></tr>';
    });
  }



</script>