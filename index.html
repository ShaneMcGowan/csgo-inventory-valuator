<!DOCTYPE html>
<html>

<head>
  <title>CSGO Inventor Valuator ❤ | Szenmu </title>
  <meta charset="UTF-8">
  <meta name="description" content="CSGO Inventory Valutaor by Szenmu ❤">
  <meta name="author" content="Szenmu">
  <meta name="viewport" content="width=device-width,height=device-height, initial-scale=1.0">
  <link href="https://fonts.googleapis.com/css?family=Roboto" rel="stylesheet">
  <script src="scroll.js"></script>
  <link rel="stylesheet" href="styles.css">
  <link rel="stylesheet" href="yacf.css">
</head>

<body>
  <!-- BEGIN Home -->
  <section id="home">
    <section id="header" class="container-v padding header ">
      <div class="col-12 fade">
        <div class="heading">
          <span class="title">
							CSGO Inventory Valuator
						</span>
          <span class="signature">
							by Szenmu
						</span>
        </div>
      </div>
      <div class="col-12 center input m-top-5 fade">
        <input id="tbxId" value="http://steamcommunity.com/id/Szenmu/" type="text" spellcheck="false" class="textBox" placeholder="Enter your Steam URL, Custom Url or Steam64ID">
        <button id="btnGo" class="button">Go!</button>
      </div>
      <svg class="arrows" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
        <path d="M7.41 7.84L12 12.42l4.59-4.58L18 9.25l-6 6-6-6z"></path>
      </svg>
    </section>
    <section id="about" class="container padding divider">
      <div class="col-12">
        <span class="title center">
						CS:GO Inventory Valuator
					</span>
        <span class="subtitle">
						A simple, easy to use Inventory valuator for CS:GO items, giving up to date prices from the most popular online market places.
					</span>
      </div>
      <div class="col-4">
        <a href="https://steamcommunity.com/market/search?appid=730" target="_blank">
						<img id="logo-steam" class="img-icon center"  src="http://i.imgur.com/f5gLouI.png">
					</a>
        <span class="subtitle">Steam</span>
      </div>
      <div class="col-4">
        <a href="https://opskins.com" target="_blank">
						<img id="logo-opskins" class="img-icon center"  src="http://i.imgur.com/YGo4ZLU.jpg">
					</a>
        <span class="subtitle">OpSkins</span>
      </div>
      <div class="col-4">
        <a href="https://bitskins.com" target="_blank">
						<img id="logo-bitskins" class="img-icon center"  src="http://i.imgur.com/0MdNUlr.png">
					</a>
        <span class="subtitle">BitSkins</span>
      </div>
    </section>
    <section class="footer padding divider title">
      <a href="https://www.twitter.com/szenmu" target="_blank">twitter</a> /
      <a href="https://www.github.com/szenmu" target="_blank">github</a>
    </section>
  </section>
  <!-- END Home -->
  <!-- BEGIN Inventory -->
  <section id="inventory">
    <section class="container center header ">
      <!-- BEGIN Profile Details -->
      <section class="col-3 container padding-2-5">
        <div class="col-12">
          <img id="profileImage" class="img-profile" src="" alt="profile image" />
        </div>
        <div class="col-12">
          <span id="profileSteamID" class="title"></span>
        </div>
        <div class="container-flex">
          <span class="col-12" id="profileSteamID64">SteamID64 : </span>
          <span class="col-12" id="profileSteamCustomURL">Custom URL : </span>
          <span class="col-12" id="profileVacBanned">Vac Banned : </span>
          <span class="col-12" id="profileTradeBanned">Trade Banned : </span>
          <span class="col-12" id="profileLimited">Limited : </span>
          <span class="col-12" id="profileLastLogin"></span>
          <span class="col-12">Steam Profile <span id="loadingSteamProfile"></span></span>
          <span class="col-12">Steam Inventory <span id="loadingSteamInventory"></span></span>
          <span class="col-12">Steam Prices <span id="loadingSteamPrices"></span></span>
          <span class="col-12">OpSkins Prices <span id="loadingOpSkinsPrices"></span></span>
          <span class="col-12">BitSkins Prices <span id="loadingBitSkinsPrices"></span></span>
        </div>
      </section>
      <!-- END Profile Details -->
      <!-- BEGIN Inventory Table -->
      <section class="col-9 container-test padding-2-5">
        <section id="types" class="col-12">
        </section>
        <section id="inventory-table" class="col-12">
          <table class="col-12 table">
            <thead>
              <tr>
                <th class="col-5">Name</th>
                <th class="col-1">Amount</th>
                <th class="col-2" id="thSteam">Steam</th>
                <th class="col-2" id="thOpSkins">OpSkins</th>
                <th class="col-2" id="thBitSkins">BitSkins</th>
              </tr>
            </thead>
            <tbody id="tableBody">
            </tbody>
          </table>
        </section>
      </section>
      <!-- END Inventory Table -->
      <div style="display:none;">

        <section class="priceStatus">

        </section>
      </div>
    </section>
  </section>
  <!-- END INVENTORY -->
</body>

</html>

<!-- -->
<script>
  let api = {
    cors: 'https://crossorigin.me/',
    inventory: {
      base: 'http://steamcommunity.com/inventory/',
      criteria: '/730/2?l=english&count=5000'
    },
    prices: {
      opskins: 'https://api.opskins.com/IPricing/GetAllLowestListPrices/v1/?appid=730',
      bitskins: '',
      steam: ''
    },
    profile: 'http://steamcommunity.com/id/TOILETROLLMAN/' // James' Inventory
  };

  let profile = {};

  let inventory = {
    filtered: [],
    unfiltered: []
  };

  let pricesOpSkins = null;
  let pricesSteam = null;
  let pricesBitSkins = null;

  let inventoryUnfiltered = [];
  let inventoryFiltered = [];

  let types = [];

  let sortByPrice = 'ascending';

  window.onload = function () {
    // Hide inventory on initial load
    document.getElementById('inventory').style.display = 'none';

    /* On enter press for that sick UX */
    document.getElementById('btnGo').addEventListener('click', function () {
      getUser();
    });

    document.getElementById('tbxId').addEventListener('keydown',function(event){
      if (event.which == 13 || event.keyCode == 13) {
        getUser();
        return false;
      }
      return true;
    });
  
    document.getElementsByClassName('arrows')[0].addEventListener('click', function () {
      smoothScroll(document.getElementById('about'));
    });

    let loadingSteamInventory = document.getElementById('loadingSteamInventory');
    let loadingOpSkinsPrices = document.getElementById('loadingOpSkinsPrices');
    let loadingSteamPrices = document.getElementById('loadingSteamPrices');
    let loadingBitSkinsPrices = document.getElementById('loadingBitSkinsPrices');

    getPricesOpSkins()
      .then(getPricesBitSkins)
      .then(getPricesSteam)

  };

  let getSteamProfile = function () {
    let promise = new Promise(function (resolve, reject) {
      console.log('Getting steam profile....');
      loadingSteamProfile.innerHTML = 'Loading...';

      callApiXML(api.cors + api.profile + '?xml=1', function (response) {
        parseProfileXML(response);
        resolve();
        populateProfile();
        loadingSteamProfile.innerHTML = 'DONE';

      });

    });
    return promise;
  };
  let getSteamInventory = function () {
    let promise = new Promise(function (resolve, reject) {
      console.log('Getting steam inventory....');
      loadingSteamInventory.innerHTML = 'Loading...';

      callApi(api.cors + api.inventory.base + profile.steamID64 + api.inventory.criteria, function (response) {
        loadingSteamInventory.innerHTML = 'DONE';
        resolve();
        handleSteamInventory(response);
      });

    });
    return promise;
  };
  let getPricesOpSkins = function () {
    let promise = new Promise(function (resolve, reject) {
      console.log('Getting OpSkins prices....');
      loadingOpSkinsPrices.innerHTML = 'Loading...';

      callApi(api.prices.opskins, function (response) {
        console.log(response);
        pricesOpSkins = response.response;
        loadingOpSkinsPrices.innerHTML = 'DONE';
        resolve();
      });

    });
    return promise;
  };
  let getPricesBitSkins = function () {
    let promise = new Promise(function (resolve, reject) {
      console.log('[TODO] Getting Bitskins prices....');
      loadingBitSkinsPrices.innerHTML = 'COMING SOON';

      /*callApi(api.prices.opskins,function(){
        resolve();
      });*/
      resolve();

    });
    return promise;
  };
  let getPricesSteam = function () {
    let promise = new Promise(function (resolve, reject) {
      console.log('[TODO] Getting Steam prices....');
      loadingSteamPrices.innerHTML = 'COMING SOON';

      /*callApi(api.prices.opskins,function(){
        resolve();
      });*/
      resolve();

    });
    return promise;
  };
  let buildProfile = function () {
    let promise = new Promise(function (resolve, reject) {
      console.log('Building profile....');
      updatePricesOpSkins();
      // TODO: updatePricesBitSkins();
      // TODO: updatePricesSteam();
      printTypes();
      populateTable(inventoryUnfiltered)
      resolve();

    });
    return promise;
  };

  function callApi(url, callback) {
    fetch(url).then(function (response) {
      return response.json();
    }).then(function (response) {
      callback(response);
    });
  }

  function callApiXML(url, callback) {
    fetch(url).then(function (response) {
      return response.text();
    }).then(function (response) {
      //TODO: Probably dont need this .then
      callback(response);
    });
  }



  /** Handle Steam inventory */
  function handleSteamInventory(response) {
    inventoryUnfiltered = inventoryGroupItems(response);
    inventoryUnfiltered = sanitiseArray(inventoryUnfiltered);
    /*  Some items have different properties, eg 2 of the same skin but with different stickers, meaning they have
        the same name but have different classids. This sorts through the items that have the same name but different class ids */
    inventoryUnfiltered = removeDuplicateNameEntries(inventoryUnfiltered);
    /* now remove all the null rows so we have no issues when making the table */
    inventoryUnfiltered = removeNullsFromArray(inventoryUnfiltered);
    /* once all items are in the right format, parse them into a list of types */
    getTypes(inventoryUnfiltered);
  }

  /** groups duplicate items together */
  function inventoryGroupItems(response) {

    // Count number of each item
    let tempInventory = [];
    response.assets.forEach(element => {
      let contains = { found: false, index: 0 };
      for (let i = 0; i < tempInventory.length; i++) {
        if (tempInventory[i].classid == element.classid) {
          contains.found = true;
          contains.index = i;
          break;
        }
      }
      if (contains.found) {
        tempInventory[contains.index].amount += 1;
      }
      else {
        tempInventory.push({
          classid: element.classid,
          amount: 1,
        });
      }
    });

    // add details to each item
    tempInventory.forEach(item => {
      for (let i = 0; i < response.descriptions.length; i++) {
        if (item.classid == response.descriptions[i].classid) {
          item.name = response.descriptions[i].market_hash_name;
          item.type = response.descriptions[i].type;
          item.tag_type = response.descriptions[i].tags[0].localized_tag_name;
          break;
        }
      }
    });

    return tempInventory
  }
  function populateTable(inventory) {
    let tableBody = document.getElementById('tableBody');
    tableBody.innerHTML = '';
    inventory.forEach(element => {
      tableBody.innerHTML += '<tr><td>' + element.name + '</td><td>' + element.amount + '</td><td>' + '♥' + '</td><td>' + '$' + element.price.toFixed(2) + '</td><td>' + '♥' + '</td></tr>';
    });
  }

  function populateProfile() {
    let profileImage = document.getElementById('profileImage').src = profile.avatarFull;
    let profileSteamID = document.getElementById('profileSteamID').innerHTML += profile.steamID;
    let profileSteamID64 = document.getElementById('profileSteamID64').innerHTML += profile.steamID64;
    let profileSteamCustomURL = document.getElementById('profileSteamCustomURL').innerHTML += profile.customURL;
    let profileVacBanned = document.getElementById('profileVacBanned').innerHTML += profile.vacBanned;
    let profileTradeBanned = document.getElementById('profileTradeBanned').innerHTML += profile.tradeBanState;
    let profileLimited = document.getElementById('profileLimited').innerHTML += profile.isLimitedAccount;
    let profileLastLogin = document.getElementById('profileLastLogin').innerHTML += profile.stateMessage;
  };

  function removeDuplicateNameEntries(array) {
    for (let i = 0; i < array.length; i++) {
      for (let j = 0; j < array.length; j++) {
        if (array[i] != null && array[j] != null && array[i].name == array[j].name && i != j) {
          array[i].amount += array[j].amount;
          array[j] = null;
        }
      }
    }
    return array;
  }
  function removeNullsFromArray(array) {
    for (let i = 0; i < array.length; i++) {
      if (array[i] == null) {
        array.splice(i, 1)
        i--;
      }
    }
    return array;
  }
  /*
  * Remove items such as stock skins from array that mess up the program
  * TODO: should not remove them but mark as something else
  */
  function sanitiseArray(array) {
    for (let i = 0; i < array.length; i++) {
      if (array[i].type.includes('Stock')) {
        array.splice(i, 1)
        i--;
      }
    }
    return array;
  }
  // Get different types from items for sorting
  function getTypes(array) {
    array.forEach(item => {
      let contains = { found: false, index: 0 };
      for (let i = 0; i < types.length; i++) {
        if (types[i].type == item.type) {
          contains.found = true;
          contains.index = i;
          break;
        }
      }
      if (contains.found) {
        types[contains.index].amount += item.amount;
      }
      else {
        types.push({
          type: item.type,
          amount: item.amount,
        });
      }
    });
    parseTypes();
  }
  // 
  function parseTypes() {
    console.log(types);
    let parsedTypes = {
      All: 0,
      StatTrak: 0,
      Sticker: 0,
      Graffiti: 0,
      Container: 0,
      Knife: 0,
      Gloves: 0,
      Skins: 0
    };

    types.forEach(type => {
      /* Extra Filters */
      parsedTypes.All += type.amount;

      if (type.type.includes('StatTrak')) {
        parsedTypes.StatTrak += type.amount;
      }
      
      /* Type Filters */
      if (type.type.includes('Sticker')) {
        parsedTypes.Sticker += type.amount;
        return;
      }
      else if (type.type.includes('Graffiti')) {
        parsedTypes.Graffiti += type.amount;
        return;
      }
      else if (type.type.includes('Container')) {
        parsedTypes.Container += type.amount;
        return;
      }
      else if (type.type.includes('Knife')) {
        parsedTypes.Knife += type.amount;
        return;
      }
      else if (type.type.includes('Gloves')) {
        parsedTypes.Gloves += type.amount;
        return;
      }
      else {
        parsedTypes.Skins += 1;
        return;
      }
    });

    types = parsedTypes;
  }

  // print types onto screen, setting up click events for sorting
  function printTypes() {
    let typeArea = document.getElementById('types');
    let print = function (type) {
      filterInventory(type);
      populateTable(inventoryFiltered);
    }
    typeArea.innerHTML += '<span id="typeAll"> All - ' + types.All + '</span>';

    typeArea.innerHTML += '<span id="typeStatTrak"> StatTrak™ - ' + types.StatTrak + '</span>';
    typeArea.innerHTML += '<span id="typeSkins"> Skins - ' + types.Skins + '</span>';
    typeArea.innerHTML += '<span id="typeKnife"> Knives - ' + types.Knife + '</span>';
    typeArea.innerHTML += '<span id="typeGloves"> Gloves - ' + types.Gloves + '</span>';
    typeArea.innerHTML += '<span id="typeSticker"> Sticker - ' + types.Sticker + '</span>';
    typeArea.innerHTML += '<span id="typeGraffiti"> Graffiti - ' + types.Graffiti + '</span>';
    typeArea.innerHTML += '<span id="typeContainer"> Container - ' + types.Container + '</span>';

    document.getElementById('typeAll').addEventListener('click', function () { print('All') }, false);
    document.getElementById('typeSticker').addEventListener('click', function () { print('Sticker') }, false);
    document.getElementById('typeGraffiti').addEventListener('click', function () { print('Graffiti') }, false);
    document.getElementById('typeContainer').addEventListener('click', function () { print('Container') }, false);
  }

  // sort types by amount 
  function sortTypesAmount(order) {
    let compare;
    if (order == 'ascending') {
      compare = function (a, b) {
        if (a.amount < b.amount)
          return -1;
        if (a.amount > b.amount)
          return 1;
        return 0;
      }
      types.sort(compare);
    }
    else if (order == 'descending') {
      compare = function (a, b) {
        if (a.amount < b.amount)
          return 1;
        if (a.amount > b.amount)
          return -1;
        return 0;
      }
      types.sort(compare);
    }
    else {
      alert('Yo, enter a correct value for sorting types friend');
    }
  }

  // sort by price
  function sortInventoryByPrice() {
    let compare;
    //already descending, change to ascending and sort ascending
    if (sortByPrice == 'descending') {
      sortByPrice = 'ascending';
      compare = function (a, b) {
        if (a.price < b.price)
          return -1;
        if (a.price > b.price)
          return 1;
        return 0;
      }
      inventoryUnfiltered.sort(compare);
    } else if (sortByPrice == 'ascending') { // already ascending, change to desecnding and sort descedning
      sortByPrice = 'descending';
      compare = function (a, b) {
        if (a.price < b.price)
          return 1;
        if (a.price > b.price)
          return -1;
        return 0;
      }
      inventoryUnfiltered.sort(compare);
    } else {
      alert('Yo, value wrong for sorting prices friend');
    }
  }

  // reset screen
  function reset() {
    inventoryUnfiltered = [];
    types = [];
    document.getElementById('total').innerHTML = '';
    document.getElementById('types').innerHTML = '';
    document.getElementById('tableBody').innerHTML = '';
  }
  function updatePricesOpSkins() {
    console.log(inventoryUnfiltered);
    inventoryUnfiltered.forEach(item => {
      // TODO: Graffiti messes this up
      try {
        item.price = (pricesOpSkins[item.name].price / 100);
      }
      catch (e) {
        item.price = 0.00;
        // shout out to cathal
      }
    });
  }
  // TODO:
  function updatePricesBitSkins() {

  }
  // TODO:
  function updatePricesSteam() {

  }

  // filter items by type
  function filterInventory(type) {
    inventoryFiltered = [];
    if (type == 'All') {
      inventoryUnfiltered.forEach(item => {
        inventoryFiltered.push(item);
      });
    }
    else {
      inventoryUnfiltered.forEach(item => {
        if (item.type.includes(type)) {
          inventoryFiltered.push(item);
        }
      });
    }
  }
  function tempPopTable(inventory) {
    let tableBody = document.getElementById('tableBody');
    tableBody.innerHTML = '';
    inventory.forEach(element => {
      tableBody.innerHTML += '<tr><td>' + element.name + '</td><td>' + '$' + element.price + '</td><td>' + element.amount + '</td></tr>';
    });
  }

  function parseProfileXML(xmlString) {
    let parser = new DOMParser();
    let xml = parser.parseFromString(xmlString, "text/xml");
    profile.steamID64 = removeCDATA(xml.getElementsByTagName("steamID64")[0].innerHTML);
    profile.steamID = removeCDATA(xml.getElementsByTagName("steamID")[0].innerHTML);
    profile.stateMessage = removeCDATA(xml.getElementsByTagName("stateMessage")[0].innerHTML);
    profile.vacBanned = removeCDATA(xml.getElementsByTagName("vacBanned")[0].innerHTML);
    profile.tradeBanState = removeCDATA(xml.getElementsByTagName("tradeBanState")[0].innerHTML);
    profile.isLimitedAccount = removeCDATA(xml.getElementsByTagName("isLimitedAccount")[0].innerHTML);
    profile.customURL = removeCDATA(xml.getElementsByTagName("customURL")[0].innerHTML);
    profile.avatarFull = removeCDATA(xml.getElementsByTagName("avatarFull")[0].innerHTML);
  }

  function removeCDATA(string) {
    return string.replace("<![CDATA[", "").replace("]]>", "");
  }

  function getUser(){
    // Hide home and show inventory
      document.getElementById('home').style.display = 'none';
      document.getElementById('inventory').style.display = 'block';

      // Get profile
      api.profile = document.getElementById('tbxId').value;
      getSteamProfile()
        .then(getSteamInventory)
        .then(buildProfile);
  }

</script>